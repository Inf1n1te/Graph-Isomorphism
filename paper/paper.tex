 \documentclass[twoside]{article}

\usepackage{amsmath,amssymb,amsthm} % Mathematical Symbols, styles, etc

\usepackage[utf8]{inputenc} % UTF-8 character encoding stuff
\usepackage[toc,page]{appendix} % appendix

% Used to enable use of the defined labeled enunciations. Usage: 
%\begin{definition}text\end{definition}
\theoremstyle{definition}
\newtheorem{definition}{Definition}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

% Python code
\usepackage{listings}
\lstset{
numbers=left,
breaklines=true
}

% --Optional-- Font and tweaking used in template
\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

% Formatting, refs and stuff
\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage{multicol} % Used for the two-column layout of the document
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{float} % Required for tables and figures in the multi-column environment - they need to be placed in specific locations with the [H] (e.g. \begin{table}[H])
\usepackage{hyperref} % For hyperlinks in the PDF

% Fancy lists. Usage: http://lmgtfy.com/?q=latex+paralist
\usepackage{paralist} % Used for the compactitem environment which makes bullet points with less space between them

% Abstract customization
\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

% Title customization
\usepackage{titlesec} % Allows customization of titles
%\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
%\renewcommand\thesubsection{\Roman{subsection}} % Roman numerals for subsections
\titleformat{\section}[block]{\large\scshape}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

% Header and footer customization
\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{T.\ Kemp, T.\ Kerkhoven, J.\ Klein Brinke, T.\ Sonderen: \shorttitle} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

% Bibliography
\usepackage[backend=bibtex, sorting=none]{biblatex}
\bibliography{references.bib}

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\articletitle}{The Effects of Preprocessing Methods on Computation Times for Graph Isomorphisms}
\newcommand{\shorttitle}{Preprocessing for Graph Isomorphisms}

\title{\vspace{-15mm}\fontsize{24pt}{10pt}\selectfont\textbf{\articletitle}} % Article title

\author{
\large
\textsc{Tim Kemp, Tim Kerkhoven, Jeroen Klein Brinke, and Tim Sonderen}\\[2mm] % Your names
\normalsize University of Twente \\ % Your institution
\normalsize \href{mailto:t.kerkhoven@student.utwente.nl}{t.kerkhoven@student.utwente.nl}, 
\href{mailto:t.kemp@student.utwente.nl}{t.kemp@student.utwente.nl},\\ \normalsize
\href{mailto:j.klein.brinke@student.utwente.nl}{j.klein.brinke@student.utwente.nl}, \href{mailto:t.sonderen@student.utwente.nl}{t.sonderen@student.utwente.nl}% Your email addresses
}

\date{\today}

%----------------------------------------------------------------------------------------

\begin{document}

\thispagestyle{empty}
\maketitle % Insert title

%----------------------------------------------------------------------------------------
%	ABSTRACT
%----------------------------------------------------------------------------------------

\begin{abstract}

\noindent Abstract here

\end{abstract}

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\begin{multicols}{2} % Two-column layout throughout the main article text

%------------------------------------------------
\section{Introduction} 

This paper will discuss the effect of several preprocessing methods on the computation time of the graph isomorphism problem. This paper will mostly focus on the algorithms and their correctness, in combination with computational experiments and their results.

The graph isomorphism problem is the computational problem of determining whether two finite graphs are isomorphic. Besides its practical importance, the graph isomorphism problem is a curiosity in computational complexity theory as it is one of a very small number of problems belonging to NP neither known to be solvable in polynomial time nor NP-complete: it is one of only 12 such problems listed by Garey \& Johnson (1979)\cite{book:garyJohnson1979}, and one of only two of that list whose complexity remains unresolved. As of 2008 the best algorithm (Eugene Luks, 1983) has run time $2^{O(\sqrt{n log n})}$ for graphs with \emph{n} vertices.\cite{article:davidJohnson2005}\cite{inproceedings:babaiCodenotti2008}\cite{website:wikiGI}

The preprocessing part are algorithms that look at the graphs before determining whether they are isomorphic with the intent of finding some characteristic that might be used to speed up the actual process of the determining whether the graphs are isomorphic.

%------------------------------------------------

\section{Scope \& Objectives}

The aim of this research paper is to determine whether certain preprocessing methods significantly reduce the time required to check whether two graphs are isomorphic. At the core, two cases will be compared: a basic case without preprocessing, and a case with preprocessing. 

For this paper, the time complexity of the algorithms will be calculated. The difference in performance between the cases will be shown by computational results as well as the calculated time complexities.

This paper will give a description of the algorithms used for preprocessing, as well as proof of correctness. The algorithms used to check for isomorphisms will be left out of consideration.

%------------------------------------------------
\section{Methods}
To determine whether the algorithms will speed up the process of finding graph isomorphisms, a computational experiment was performed. In this experiment, the algorithms were used on a variety of differently shaped graphs, and sets of graphs, in conjunction with an algorithm which checks for isomorphisms.

\subsection{Experiment Setup}
For the testing, a single laptop was used to collect all the timed data. The tests were run in JetBrains' PyCharm, using the built-in functions to run the python code. The python interpreter used was Python 3.4 and the laptop was running Windows 8.1 @ 1.6 GHz/ 3.67GB RAM at the time of the testing. Efforts were made to ensure all the testing was performed under the same circumstances.

\subsection{Testing}
In the experiment, two cases were tested: a basic case, without preprocessing, and a case with preprocessing. In both cases a timer was added to the code. The timer started before any other piece of code, and ended only after the algorithms were completely finished. This way everything is timed, including the loading of the graph, the additional time used to run preprocessing algorithms and finding of the isomorphisms.

For every chosen test instance, the run times for both algorithms was determined. After all testing all instances had been completed, the results were compared.

%------------------------------------------------
\section{Description of Algorithms}
For hard instances of the graph isomorphism problem, the coarsest stable coloring of a graph still has a lot of colors which are not unique. Two structures for which this is the case are twins and false twins, they are defined in definition \ref{deftwins} and \ref{deffalsetwins}.
\begin{definition}
Let $G = (V,E)$ be a graph. The \emph{neighbourhood} $N(v)$ of $v \in V$ is:
$N(v) = \left\{{u \in V : \{u,v\} \in E}\right\}$
\end{definition}
\begin{definition}\label{deftwins}
Let $G = (V,E)$ be a graph.
Two vertices $u, v \in V$ are \emph{twins} if $\{u,v\} \in E$ and $N(u)\textbackslash {v} = N(v)\textbackslash {u}$.
\end{definition}
\begin{definition}\label{deffalsetwins}
Let $G = (V,E)$ be a graph.
Two vertices $u, v \in V(G)$ are \emph{false twins} if $N(u) = N(v).$
\end{definition}

To solve the graph isomorphism problem more efficiently, we use preprocessing algorithms which replaces twins and false twins by single precolored vertices such that:
\begin{compactenum}
\item Twins have the same color $\iff$ Twins have the same size (number of vertices).
\item False twins have the same color $\iff$ False twins have the same size (number of vertices).
\item A twin and a false twin can't have the same color.
\end{compactenum}

\subsection{Implementation}
The algorithm is divided into two subalgorithms. The subalgorithm \textit{gettwins} finds all twins and false twins and the subalgorithm \textit{preprocessing} replaces each (false) twin by a single colored vertex as described above. In the following subsections these algorithms and their worst case time complexities will be analyzed. The elementary operation is the comparison of two elements. In those subsections $n$ is the number of vertices of a graph $G(V,E)$ and $m$ is the number of edges of that graph.

\subsubsection{Finding twins and false twins}
The algorithm \emph{gettwins} can be found in appendix \ref{gettwins}. In line 2-10 two lists, \emph{nbs} and \emph{nbs2}, are created. Both lists contains $n$ sorted sublists. In the former list each sublist contains all the neighbours of a node and in the latter each sublist contains all the neighbours of a node and also the node itself. Finding all the neighbours only require going though all the edges once, so the time complexity is $O(m)$. The sorting algorithm has time complexity $O(n \log n)$, but since it's in a for loop of length $n$ the overall time complexity becomes $O(n^2 \log n)$. 

In line 11-16 a dictionary \emph{falsetwins} is created where the keys are all the items from \emph{nbs} and the values a list of the corresponding vertices. Since \emph{nbs} has length $n$ and \emph{falsetwins} has at most length $n$, the time complexity of this is $O(n^2)$. In line 23 the items in the \emph{falsetwins} with only one vertex as value are removed. This is $O(n)$, since len() has $O(1)$.\cite{website:pythonTimeComplexity} The remaining values of the dictionary \emph{falsetwins} are now all the sets of false twins as defined in definition \ref{deffalsetwins}. A similar dictionary \emph{twins} is created where the keys are the items from \emph{nbs2}. The time complexity of \textit{gettwins} is thus $O(n^2 \log n)$.


\subsubsection{Replacing the twins}
The algorithm \emph{preprocessing} can be found in appendix \ref{preprocessing}. In line 2 the twins and falsetwins are defined and if there are none the program will terminate. If there are any twins all edges with a head or tail in one of these twins will be deleted. The complexity of this is $O(m +$ number of vertices (\emph{twins}+\emph{falsetwins}))$ < O (nm)$. Then in line 13-19 all vertices which are in twins or falsetwins will be removed. The complexity of this is $O(n^2)$. In line 20-28 a new colored vertex will be added for each (false) twin $(O(n)$ and finnaly the edges from these vertices will be added ($O(n^2 (n+m)$). The worst case complexity of this algorithm is ($O(n^2 (n+m)$), however in average there are much less (false) twins than vertices (there are at most $n/2$). These twins also have much less than $n$ neighbours.

%------------------------------------------------
\section{Proof of Correctness}
NOG NIET AF!
\begin{definition}
A \emph{colored} graph $G(E,V)$ is a graph where each vertex $v \in V$ has a color label.
\end{definition}
\begin{definition}
Let $G_1 = (V_1, E_1)$ and $G_2 = (V_2, E_2)$ be two undirected colored graphs. A function $f: V_1 \to V_2$ is called a \emph{graph isomorphism} if (a) $f$ is a bijection, (b) for all $a, b \in V_1, \{a, b\} \in E_1$ if and only if $\{f(a), f(b)\} \in E_2$, and (c) $color(v)$ = $color (f(v)$. When such a function exist, $G_1$ and $G_2$ are called \emph{isomorphic graphs}. 
\end{definition}
\begin{theorem}
Let $G_1 = (V_1, E_1)$ and $G_2 = (V_2, E_2)$ be two undirected colored graphs where each vertex has the same color and let $H_1 = (V_1, E_1)$ and $H_2 = (V_2, E_2)$ be resp. the same graphs as $G_1$ and $G_2$ where each (false) twin is replaced by a colored vertex such that: \begin{enumerate}
\item Twins (False twins) have the same color $\iff$ Twins (False twins) have the same size (number of vertices).
\item A twin and a false twin can't have the same color.
\end{enumerate}
Graph $G_1$ and $G_2$ are isomorphic $\iff$ Graph $H_1$ and $H_2$ are isomorphic.
\begin{proof}
Todo
\end{proof}

%bron http://pages.cs.wisc.edu/~dieter/Papers/3gi.pdf

%------------------------------------------------
\section{Computational Experiments}

Computational Experiments here\\
Setup good experiments beforehand and test extensively

%------------------------------------------------
\section{Results}

Results here

%------------------------------------------------
\section{Conclusions}

Conclusions here \\
Is it faster?

%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------

\printbibliography

%----------------------------------------------------------------------------------------



\end{multicols}
\newpage
\begin{appendices}

\section{Python code}
\lstset{language=Python}
\begin{lstlisting}[label={gettwins}]
def gettwins(g):
    nbs = []
    nbs2 = []
    for vertex in g.V():
        nb = vertex.nbs()[:]
        nb.sort(key=lambda x: x._label)
        nbs.append(tuple(nb))
        nb.append(vertex)
        nb.sort(key=lambda x: x._label)
        nbs2.append(tuple(nb))
    falsetwins = {}
    for i, item in enumerate(nbs):
        if item in falsetwins.keys():
            falsetwins[item].append(g.V()[i])
        else:
            falsetwins[item] = [g.V()[i]]
    twins = {}
    for i, item in enumerate(nbs2):
        if item in twins.keys():
            twins[item].append(g.V()[i])
        else:
            twins[item] = [g.V()[i]]
    falsetwins = {k: v for k, v in falsetwins.items() if len(v) > 1}
    twins = {k: v for k, v in twins.items() if len(v) > 1}
    return list(falsetwins.values()), list(twins.values()), list(falsetwins.keys()), list(twins.keys())   
\end{lstlisting}

\section{Table with computation times}
\begin{tabular}{c|c|c}
Graph & Computation time (without preprocessing) & Computation time (with preprocessing) \\
\hline
cographs1 & 146.8098 sec & 0.0171 sec \\
hugecographs & >30 min & 662.5381 sec \\
cycles175 & 69.8579 & 70.8041 sec \\
bigtrees3 & 8.2151 & 2.5008\\
cubes6 & -1 & -1\\
products72 & -1 & -1\\
torus72 & -1 & -1\\

\end{tabular}


\begin{lstlisting}[label={preprocessing}]
def preprocessing(g):
	falsetwins, twins, falsetwinsN, twinsN = gettwins(g)
	lftwins = len(falsetwins)
	ltwins = len(twins)
	if lftwins != 0 or ltwins != 0:
		deledges = []
		for i, e in enumerate(g._E):
			if any(e._tail in ftwin for ftwin in falsetwins) or any(e._head in ftwin for ftwin in falsetwins) or any(e._tail in twin for twin in twins) or any(e._head in twin for twin in twins):
				deledges.append(i)
		deledges.sort(reverse=True)
		for i in deledges:
			g._E.pop(i)
		delnodes = []
		for i, V in enumerate(g._V):
			if any(V in ftwin for ftwin in falsetwins) or any(V in twin for twin in twins):
				delnodes.append(i)
		delnodes.sort(reverse=True)
		for i in delnodes:
			g._V.pop(i)
		combined = falsetwinsN + twinsN
		mx = 0
		for i, twin in enumerate(falsetwins):
			g.addvertexobject(twin[0], True, len(twin))
			twin[0].colornum = -twin[0].twinsize
			mx = max(mx, len(twin))
		for i, twin in enumerate(twins):
			g.addvertexobject(twin[0], True, len(twin) + mx)
			twin[0].colornum = -twin[0].twinsize - mx
		for i, twin in enumerate(falsetwins + twins):
			for j in combined[i]:
				if j in g.V() and twin[0] != j and not g.findedge(twin[0],k)
					g.addedge(twin[0], j)
		g._V.sort(key=lambda x: x._label)
	return g, lftwins, ltwins
\end{lstlisting}

\section{Table with computation times}
\begin{tabular}{c|c|c|c}
Graph & Computation time (without preprocessing) & Computation time (with preprocessing) & Preprocessing time \\
\hline
cographs1 & 146.8098 sec & 0.0171 sec & 0.0056 sec \\
hugecographs & >30 min & 662.5381 sec & 0.0316 sec \\
cycles175 & 69.8579 sec & 70.8041 sec & 0.0215 sec\\
bigtrees3 & 8.2724 sec & 2.8264 & 0.0499 sec\\
cubes6 & -1 & -1\\
products72 & -1 & -1\\
torus72 & -1 & -1\\
\end{tabular}

\end{appendices}




\end{document}